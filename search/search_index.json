{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to <code>Category Theory through Math and Programming for Dummies</code>","text":""},{"location":"#project","title":"Project","text":"<p>The aim of the  project is to provide an introdcution to category theory concepts, their connections to other areas of mathematics and applications in programming. </p> <p>The current \"book\" in no way is a comprehensive guide to category theory or its applications. We want to emphasize that the author is not an expert in either category theory or functional programming. The book is an attepmt to learn and understand the concepts of category theory and its applications in programming and provide a resource for others who are interested in the same to leanr and contribute to the project.</p>"},{"location":"basics/formal_definitions/","title":"Formal Definitions","text":""},{"location":"basics/formal_definitions/#definition-of-category","title":"Definition of Category:","text":"<p>A Category \\(\\mathcal{C}\\) consists of two classes; </p> <ul> <li> <p>The class of its objects: \\(obj(\\mathcal{C})\\) and </p> </li> <li> <p>The class of morphisms \\( mor_{{\\mathcal{C}}}(\\mathcal{C})\\).</p> </li> </ul> <p>Each morphism \\(f\\in mor_{{\\mathcal{C}}}(\\mathcal{C})\\)of the morphisms class has a source object \\(A\\) and a target object \\(B\\), and is denoted as \\(f\\colon A \\to B\\). </p> <p>We denote \\(mor_{{\\mathcal{C}}}(A, B)\\) the class of all morphisms betwen the objects \\(A\\) and \\(B\\).</p> <ul> <li> <p>There is a binnary opperation \\(\\circ\\) on the class of Morphisms called morphism compositions:   \\[ \\circ \\colon mor_{{\\mathcal{C}}}(A, B) \\times mor_{{\\mathcal{C}}}(B, C) \\to mor_{{\\mathcal{C}}}(A, C).\\]    Which allows to combine any two morphisms \\(f\\in mor_{{\\mathcal{C}}}(A, B)\\) and \\(g\\in mor_{{\\mathcal{C}}}(B, C)\\) to  produce a new morphism \\(g\\circ f\\in mor_{{\\mathcal{C}}}(A, C)\\).</p> <p> </p> </li> </ul> <p>So that the follwoing properties hold:</p> <ul> <li> <p>Assocaiativity: If there are are different ways of composing morphisms, the result should be the same.</p> <p>For any \\(f\\in mor_{{{\\mathcal{C}}}}(A, B)\\), \\(g\\in mor_{{{\\mathcal{C}}}}(B, C)\\) and \\(h\\in mor_{{{\\mathcal{C}}}}(C, D)\\) \\[h\\circ(g\\circ f) = (h\\circ g)\\circ f.\\]</p> <p> <li> <p>Identity: For each object, there exists an identity morphism that acts as a neutral element (identity) for the composition of morphisms.</p> <p>There exisits <code>identity</code> morphisms for each object \\(1_{X}\\in mor_{\\mathcal{C}}(X, X),\\, \\forall X\\in obj(\\mathcal{C})\\)  such that for any \\(f\\in mor_{\\mathcal{C}}(A, B)\\) \\[1_{B}\\circ f= f\\circ 1_{A}.\\]</p> <p>"},{"location":"basics/formal_definitions/#functors","title":"Functors","text":"<p>The categories themselves can by \"higher level arrows\" which are called Functors. Latter, are mappings between categories that preserve the inner relationships (morphisms and their composition) between the objects.</p> <p>As such, Functors establish analogies between two categories, and they can be used to translate the concepts from one category to another.</p>"},{"location":"basics/formal_definitions/#natural-transformations","title":"Natural Transformations","text":"<p>The Natural Transformation is a concept which allows to define connections between Functors.</p> <p>Let \\(F, G\\) be two functors between the categories \\( \\mathcal{C}_1 \\) and \\( \\mathcal{C}_2 \\). A natural transformation is a collection \\[   \\eta:= \\{      \\eta_A \\in     mor_{_{\\mathcal{C}_2}}(F(A), G(A))     \\colon A \\in obj(\\mathcal{C}_1)      \\}, \\] such that</p> <ul> <li> <p>\\(\\eta_A\\) is a morphism from \\(F(A)\\) to \\(G(A)\\), for each \\(obj(\\mathcal{C}_1)\\).</p> </li> <li> <p>The above morphism relate the way the to Functors transform objects such that for every morphism \\(f\\colon A \\mapsto B\\), \\(A, B\\in obj(\\mathcal{C}_1)\\), we have \\[\\eta_B\\circ F(f) = G(f)\\circ \\eta_A.\\]</p> </li> </ul> <p>This is illustrated in the following diagram with the commutative diagram that should hold for each morphism \\(\\eta_{X}, \\eta_{Y}\\) associated to the objects \\(X, Y\\) in the categories.</p>"},{"location":"basics/functors/","title":"Functors","text":"<p>This section explores various falvors of <code>Functors</code>, their role in mathematics, and their usage in programming.</p> Scala <p>```scala // Scala example of a functor trait Functor[F[_]] { def mapA, B(f: A =&gt; B): F[B] }</p> <p>```</p> Haskell <pre><code>-- Haskell example of a functor\nclass Functor f where\nfmap :: (a -&gt; b) -&gt; f a -&gt; f b\n</code></pre>"},{"location":"basics/morphisms/","title":"Morphisms","text":"<p>In this sectoin we go deeper into the concept of morphisms in category theory and will discuss specicfic examples in Mathematics and Programming.</p>"},{"location":"intro/","title":"Category Theory for Programming","text":"<p><code>Categoy Theory</code> is a tool for writing and executing code in multiple programming languages in a single document. It is based on the idea of a category, which is a mathematical structure that consists of objects and morphisms. In the context of programming languages, objects are types and morphisms are functions. </p> <p><code>Categoy Theory</code> allows you to define objects and morphisms in different programming languages and compose them together to create new functions.</p>"},{"location":"intro/introduction-to-category-theory/","title":"Informal Introduction","text":"<p>A central idea in mathematics is that <code>objects in mathematics are defined by the relationships they have with other objects</code> rather than by their intrinsic properties. This idea is the basis of category theory, which allows to unify constructions and draw analogies between different branches of mathematics. </p> <p>In essence, category theory allows to formalise the idea of associacions between different mathematical structures and associations between associations.</p> <p>\"A mathematician is a person who can find analogies between theorems; a better mathematician is one who can see analogies between proofs and the best mathematician can notice analogies between theories. One can imagine that the ultimate mathematician is one who can see <code>analogies between analogies.</code>\"</p> <p>Stefan Banach</p> <p>Category Theory  is a branch of mathematics which studies the abstraction of objects and their relations. The basic entities of category theory are Categories , which are collections of objects and connections/arrows between them.</p>"},{"location":"intro/introduction-to-category-theory/#main-concepts","title":"Main Concepts","text":"<p>The main concepts of the category theory are Morphisms, Functors, and Natural Transformations.</p>"},{"location":"intro/introduction-to-category-theory/#morphisms","title":"Morphisms","text":"<p>The arrows are called Morphisms, which are the functions that operate on the objects, they relate one object called the source to another called the target of the morphism.</p> <ul> <li>Morphism are conncetions between the objects and are displayed with arrows in the diagrams. </li> <li>Morphism can be combined transitively to form new morphism.</li> <li>Each object is associated with an Identity Morphism (a circular arrow to itslef) which does not change other morphism when combined with them.</li> </ul>"},{"location":"intro/introduction-to-category-theory/#functors","title":"Functors","text":"<p>The categories themselves can by \"higher level arrows\" which are called Functors. Latter, are mappings between categories that preserve the inner relationships (morphisms and their composition) between the objects.</p> <p>As such, Functors <code>establish analogies between two categories</code>, and they can be used to translate the concepts from one category to another.</p>"},{"location":"intro/introduction-to-category-theory/#natural-transformations","title":"Natural Transformations","text":"<p>The Natural Transformation is a concept which allows to define <code>connections between Functors</code> in a sense analogus to what are Morphisms for objects. A such they establish dualities between Functors and objects in the categories. </p> <p>Since the Functors are defined by the way they transform each objects, to define connections between them we need to define  a <code>natural</code> way to transform images of each object by the two Functors.</p> <p>Thus, a Natural Transformation is achieved via a family of morphism associated with each objects in the categories. Each object in the source category corresponds to a morphism in the target category, which maps the image of the object under the first functor to its image under the second functor. These morphisms enable us to relate how each functor transforms objects and morphisms. A natural transformation is established when there is consistency between the transformations induced by these morphisms and the transformations applied by the functors to objects and morphisms.</p>"},{"location":"intro/introduction-to-category-theory/#category-theory-and-programming","title":"Category Theory and Programming","text":"<p>The parallel between the category theory and the programming is that \u043ene can think of the objects as the data types and the arrows as the functions that connect the data types. The parallelism allows to use the category theory to reason about the programs and to develop programming concepts which can stay consistent exploiting the concepts of the category theory.</p> <p>An analogy can be made between the category theory and the programming languages. The objects in the category theory are like the types in the programming languages, and the morphisms are like the functions that operate on the types. The category theory provides a way to reason about the types and functions in the programming languages.</p> <p>Let's consider the example of morphism between objects of 'Int' and 'String' types. The morphism is a function that converts an integer to a string. The function is defined in the programming language as follows:</p> PythonScalaHaskell <pre><code>def int_to_string(x: int) -&gt; str:\n    return str(x)\n\ndef string_to_bool(x: str) -&gt; bool:\n    return bool(x)\n\ndef int_to_bool(x: int) -&gt; bool:\n    return bool(x)\n</code></pre> <pre><code>def intToString(x: Int): String = x.toString\n\ndef stringToBool(x: String): Boolean = x.toBoolean\n\ndef intToBool(x: Int): Boolean = x.toBoolean\n</code></pre> <pre><code>intToString :: Int -&gt; String\nintToString x = show x\n\nstringToBool :: String -&gt; Bool\nstringToBool x = read x\n\nintToBool :: Int -&gt; Bool\nintToBool x = x /= 0\n</code></pre>"},{"location":"preliminaries/","title":"Preliminaries","text":"<p>In this section, we will introduce some basic concepts and definitions that are used throughout the book. These concepts are fundamental to understanding the rest of the material.</p>"},{"location":"preliminaries/basic_algebra/","title":"Introduction to Algebra","text":"<p>We continue with a brief introduction to some fundaentalalgebraic structures.</p>"},{"location":"preliminaries/basic_algebra/#monoid","title":"Monoid","text":"<p>A Monoid is a basic algebraic structure consisting of a set combined with a binary operation that is associative and has an identity element.</p>"},{"location":"preliminaries/basic_algebra/#definition","title":"Definition","text":"<p>A monoid is defined by the following properties:</p> <ul> <li>Associativity: For all \\(a, b, c\\) in \\(M\\),   \\[   (a \\cdot b) \\cdot c = a \\cdot (b \\cdot c)   \\]</li> <li>Identity Element: There exists an element \\(e \\in M\\) such that for every element \\(a \\in M\\),   \\[   e \\cdot a = a \\cdot e = a   \\]</li> </ul>"},{"location":"preliminaries/basic_algebra/#example","title":"Example","text":"<p>A simple example of a monoid is the set of natural numbers \\(\\mathbb{N}\\) including zero, with addition as the operation. Here, the identity element is \\(0\\).</p> HaskelScalaPython <pre><code>-- Haskell example of a monoid operation\nadd :: Int -&gt; Int -&gt; Int\nadd x y = x + y\n\nidentity :: Int\nidentity = 0\n</code></pre> <pre><code>// Scala example of a monoid operation\ndef add(x: Int, y: Int): Int = x + y\n\nval identity: Int = 0\n</code></pre> <pre><code># Python example of a monoid operation\ndef add(a, b):\n    return a + b\n\nidentity = 0\n</code></pre>"},{"location":"preliminaries/basic_algebra/#category-theoretic-perspective","title":"Category Theoretic Perspective","text":"<p>In category theory, a monoid can be seen as a category with a single object. The object's morphisms are the elements of the monoid, and the composition of morphisms corresponds to the monoid operation.</p>"},{"location":"preliminaries/basic_algebra/#group","title":"Group","text":"<p>A Group is like a monoid but also requires each element to have an inverse.</p>"},{"location":"preliminaries/basic_algebra/#definition_1","title":"Definition","text":"<p>A group is defined by all the properties of a monoid with the addition of:</p> <ul> <li>Inverse Element: For every element \\(a \\in G\\), there exists an element \\(b \\in G\\) such that,   \\[   a \\cdot b = b \\cdot a = e   \\]</li> </ul>"},{"location":"preliminaries/basic_algebra/#example_1","title":"Example","text":"<p>An example of a group is the set of integers \\(\\mathbb{Z}\\) with addition. Each integer \\(a\\) has an inverse \\(-a\\).</p> <pre><code># Python example of a group operation\ndef add(a, b):\n    return a + b\n\ndef inverse(a):\n    return -a\n\nidentity = 0\n</code></pre>"},{"location":"preliminaries/basic_algebra/#category-theoretic-perspective_1","title":"Category Theoretic Perspective","text":"<p>A Monoid can be seen as a category with one object, while a Group can be seen as a category with one object where every morphism has an inverse (i.e. is an isomorphism).</p>"},{"location":"preliminaries/basic_algebra/#illustrations","title":"Illustrations","text":""},{"location":"preliminaries/set_theory/","title":"Set Theory; sets and classes","text":"<p>We will start with the basic concepts of set theory. Set theory is the branch of mathematics that studies sets - collection of objects.</p>"},{"location":"preliminaries/set_theory/#sets","title":"Sets","text":"<p>A set is a collection of objects. The objects in a set are called elements or members of the set. A set is denoted by curly braces <code>{}</code>. For example, the set of natural numbers is denoted by  \\[\\mathbb{N} = \\{ 0, 1, 2, 3, \\ldots \\}.\\]</p> <p>The formal definition of a set is given by the axioms of set theory. The axioms of set theory are a set of rules that define the properties of sets.  A wildley used set of axioms is the <code>Zermelo-Fraenkel</code> set theory with the axiom of choice (ZFC).</p> <p>To formaly define the axiom one needs to intruce terminology of formal logic, which is beyond the scope of this document. However, the axioms can be informally described as follows.</p> <p>ZFC Axioms:</p> <ol> <li>Axiom of Extensionality: Two sets are equal if they have the same elements.      </li> <li>Axiom of Regularity: Every non-empty set has an element that is disjoint from the set.      </li> <li>Axiom of Pairing: For any two sets \\(a\\) and \\(b\\), there exists a set \\({a, b}\\) that contains \\(a\\) and \\(b\\) as elements.</li> <li>Axiom of Union: For any set \\(a\\), there exists a set \\(\\bigcup a\\) that contains all the elements of the sets in \\(a\\).</li> <li>Axiom of Power Set: For any set \\(a\\), there exists a set \\(\\mathcal{P}(a)\\) that contains all the subsets of \\(a\\).</li> <li>Axiom of Infinity: There exists a set \\(\\mathbb{N}\\) that contains the natural numbers.</li> <li> <p>Axiom of Replacement: For any set \\(a\\) and any function \\(f\\), there exists a set \\(\\{f(x) | x \\in a\\}\\) that contains the images of the elements of \\(a\\) under \\(f\\).</p> <p>and the axiom of choice:</p> </li> <li> <p>Axiom of Choice: For any set \\(a\\) of non-empty sets, there exists a set \\(c\\) that contains exactly one element from each set in \\(a\\).</p> </li> </ol>"},{"location":"preliminaries/set_theory/#classes","title":"Classes","text":"<p>The axiomatization of set theory was developed by Georg Cantor in the late 19th century. Cantor's work was based on the idea of a class. As the naive set theory encountered paradoxes, mathematicians began to develop a more rigorous theory of sets. The Zermelo-Fraenkel set theory with the axiom of choice (ZFC) is the most widely used set theory today. One of intuitivistic paradoxes that led to the development of ZFC is the Cantor's paradox that there is no set of all sets. The paradox arises from the set of all sets that do not contain themselves. If such a set exists, then it must contain itself, which contradicts the definition of the set. The paradox is resolved by introducing the concept of a class.</p> <p>A class is a collection of sets. The objects in a class are called sets. A class is denoted by square brackets <code>[]</code>. For example, the class of all sets is denoted by \\({x | x = x}\\). The class of all sets is not a set because it contains itself. The class of all sets is called a proper class. A proper class is a class that is not a set. The class of all sets is a proper class because it contains itself.</p>"},{"location":"preliminaries/set_theory/#mappings","title":"Mappings","text":"<p>A mapping is a relation between two sets that associates each element of the first set with exactly one element of the second set. A mapping is denoted by an arrow \\(\\to\\). For example, the mapping</p> <p>\\[f: A \\to B\\]</p> <p>associates each element of set \\(A\\) with exactly one element of set \\(B\\).</p> <p>The set \\(\\mathbb{A}\\) is called the domain of the mapping, and the set \\(B\\) is called the codomain of the mapping. The element of the set \\(A\\) is called the input of the mapping, and the element of the set \\(B\\) is called the output of the mapping. The mapping \\(f\\) is called a function if it associates each element of set \\(A\\) with exactly one element of set \\(B\\).</p>"}]}